---
title: "알고리즘: 소수 판별법 알고리즘"
categories:
    - Blog
tags:
    - 알고리즘
---

## 소수(prime number)란 무엇인가?

1보다 큰 자연수 중 1과 자기 자신만을 약수로 가지는 수를 말한다.

## 1. 가장 기본적인 방법

소수를 판별하는 가장 단순한 방법은 2 ~ N-1까지 모두 나눠보는 방법이다. 
하지만 단순한 만큼 만족스러운 성능을 기대하기는 어렵다. 한 개의 수에 대한 소수 판별은 O(N)의 시간복잡도를 가지게 되며 N개의 수로 확장시 시간 복잡도는 O(N^2)으로 커져 알고리즘 문제풀이에서 사용하기 어렵다.

## 2. 약수의 특성을 활용한 방법 (제곱근)

이는 약수의 특성 때문에 가능하다. 특정 수 N의 약수들은 크기 순으로 나열했을 때, 가운데 수를 중심으로 대칭된 위치의 약수들끼리 곱했을 때 N이 나옴을 알 수 있다. 때문에 가운데 약수를 중심으로 이보다 작은 수들만 약수인지 판별하면 나머지 반쪽(가운데 약수보다 큰 수들)에 대해서도 판별한 것과 같다.

16을 예로 들어보면 16의 약수들은 1, 2, 4, 8, 16으로 총 5개이며 가운데 약수인 4를 기준으로 대칭된 위치의 약수의 곱은 16을 만든다. 그래서 16의 약수를 찾을 때 16의 약수의 중간값을 기준으로 한쪽만 (이 경우 작은 쪽) 검사를 해도 다른 쪽의 약수들을 알 수 있다.

중간값을 N의 제곱근으로 설정하면 대략적인 약수의 중간값이라고 가정할 수 있으며, 이 중간값보다 작은 약수가 없으면 중간값보다 큰 약수도 존재하지 않는다고 결론을 내릴 수 있다. 

결론적으로 기존 풀이에서 2 ~ N-1까지였던 반복문을 2 ~ N의 제곱근까지로 축소해도 소수 여부를 판별할 수 있으며 연산횟수도 줄여 O(sqrt(N))의 시간복잡도이다.

### 2.1 알고리즘

1. 1은 소수가 아니므로 false 처리
2. 짝수는 소수가 아니므로 false 처리 (단, 2는 짝수이면서 소수이므로 예외처리)
3. N을 2 ~ N제곱근까지로 나눠본 후 하나라도 나눠떨어지면 false 처리
4. N을 N제곱근까지 나눴음에도 나눠떨어지지 않는 경우 소수로 판별

### 2.2 시간복잡도

* 시간복잡도: O(sqrt(N))

## 3. 에라토스테네스의 체

해당 방식은 한 개의 수에 대해 판별하기보다 여러 개의 수에 대해 소수인지를 판별해야 하는 상황에서 유용하게 사용된다.

"소수 n의 배수는 약수로 무조건 n을 포함하므로 소수가 될 수 없다"는 사실을 이용한다.

2부터 최대크기의 수 M까지를 차례대로 나열한 배열에서 시작한다. 가장 작은 소수 2부터 시작하여 배열에서 2의 배수를 모두 지웠으면, 지워지지 않은 수 중 다음 값인 3의 배수를 지워나가고, 다시 지워지지 않은 수 중 다음 값인 5의 배수를 지워나가는 식으로 반복해 나가면 배열에서 지워지지 않고 남은 수들이 소수이다.

앞의 방법에서 N의 제곱근까지에 대해서만 나눠봐도 소수인지 판별할 수 있음을 봤으므로 여기서도 N의 제곱근보다 작거나 같은 수의 배수까지 지우면 남은 수는 모두 소수이다.

해당 방법은 O(nlog(log(n)))의 시간복잡도를 가진다.

### 3.1 알고리즘

1. 2 ~ N까지 담긴 배열을 만든다.
2. 해당 배열 내의 가장 작은 수 i의 배수들을 해당 배열에서 지운다. (i는 소수이므로 지우지 않는다)
3. 주어진 범위 내에서 i의 배수를 모두 지웠으면 i 다음으로 작은 수의 배수를 같은 방식으로 배열에서 지운다.
4. 더 이상 반복할 수 없을 때까지 2,3번을 반복한다. (N의 제곱근의 배수까지 지울때까지 반복한다.)

### 3.2 시간복잡도

* 시간복잡도: O(nlog(log(n)))
